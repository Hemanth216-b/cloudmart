
![Screenshot 2025-03-04 120607](https://github.com/user-attachments/assets/6b2005b8-8093-43d9-8eac-effc012fcd73)

# MultiCloud, DevOps & AI Challenge Creating the E-commerse application called cloudmart
## Step 1: Use Claude to Generate Terraform Code

1. Start a conversation with [Claude](https://claude.ai/).
2. Ask Claude to create Terraform code for an S3 bucket. Use a prompt like:
"Please provide Terraform code to create an S3 bucket in AWS with a unique name."
3. Claude should generate code similar to this:
    
    ```
    provider "aws" {
      region = "us-west-2"  # Replace with your desired region
    }
    
    resource "random_id" "bucket_suffix" {
      byte_length = 8
    }
    
    resource "aws_s3_bucket" "my_bucket" {
      bucket = "my-unique-bucket-name-${random_id.bucket_suffix.hex}"
    
      tags = {
        Name        = "My bucket"
        Environment = "Dev"
      }
    }
    
    resource "aws_s3_bucket_acl" "my_bucket_acl" {
      bucket = aws_s3_bucket.my_bucket.id
      acl    = "private"
    }
    
    ```
    
4. Save this code for use in Step 5.

## Step 2: Create IAM Role for EC2

1. Log in to the AWS Management Console.
2. Navigate to the IAM dashboard.
3. Click "Roles" in the left sidebar, then "Create role".
4. Choose "AWS service" as the trusted entity type and "EC2" as the use case.
5. Search for and attach the "AdministratorAccess" policy.
Note: In a production environment, use a more restricted policy.
6. Name the role "EC2Admin" and provide a description.
7. Review and create the role.

## Step 3: Launch EC2 Instance

1. Go to the EC2 dashboard in the AWS Management Console.
2. Click "Launch Instance".
3. Choose an Amazon Linux 2 AMI.
4. Select a t2.micro instance type.
5. Configure instance details:
    - Network: Default VPC
    - Subnet: Any available
    - Auto-assign Public IP: Enable
    - IAM role: Select "EC2Admin"
6. Keep default storage settings.
7. Add a tag: Key="Name", Value="workstation".
8. Create a security group allowing SSH access from EC2 Connect IP.
9. Review and launch, selecting or creating a key pair.

## Step 4: Connect to EC2 Instance and Install Terraform

1. From the EC2 dashboard, select your "workstation" instance.
2. Click "Connect" and use the "EC2 Instance Connect" method.
3. In the browser-based SSH session, update system packages:
    
    ```
    sudo yum update -y
    
    ```
    
4. Install yum-utils:
    
    ```
    sudo yum install -y yum-utils
    
    ```
    
5. Add HashiCorp repository:
    
    ```
    sudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/AmazonLinux/hashicorp.repo
    
    ```
    
6. Install Terraform:
    
    ```
    sudo yum -y install terraform
    
    ```
    
7. Verify installation:
    
    ```
    terraform version
    
    ```
    

## Step 5: Apply Terraform Configuration

1. Create a new directory and navigate to it:
    
    ```
    mkdir terraform-project && cd terraform-project
    
    ```
    
2. Create and open [main.tf](http://main.tf/):
    
    ```
    nano main.tf
    
    ```
    
3. Paste the Terraform code generated by Claude in Step 1.
4. Save and exit the editor (in nano, press Ctrl+X, then Y, then Enter).
5. Initialize Terraform:
    
    ```
    terraform init
    
    ```
    
6. Review the plan:
    
    ```
    terraform plan
    
    ```
    
7. Apply the configuration:
    
    ```
    terraform apply
    
    ```
    
8. Type "yes" when prompted to create the resources.

## Step 6: Verify S3 Bucket Creation

1. Use AWS CLI to list buckets:
    
    ```
    aws s3 ls
    
    ```
    
2. Verify that your new bucket is in the list.

## Step 7: Create the Cloud DynamoDB tables

Remove the S3 lines and add the lines below to create the DynamoDB tables used by CloudMart

```bash
provider "aws" {
  region = "us-east-1"  
}

# Tables DynamoDB
resource "aws_dynamodb_table" "cloudmart_products" {
  name           = "cloudmart-products"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "id"

  attribute {
    name = "id"
    type = "S"
  }
}

resource "aws_dynamodb_table" "cloudmart_orders" {
  name           = "cloudmart-orders"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "id"

  attribute {
    name = "id"
    type = "S"
  }
}

resource "aws_dynamodb_table" "cloudmart_tickets" {
  name           = "cloudmart-tickets"
  billing_mode   = "PAY_PER_REQUEST"
  hash_key       = "id"

  attribute {
    name = "id"
    type = "S"
  }
}

```

1. Apply the configuration:
    
    ```
    terraform apply
    
    ```
    
2. Type "yes" when prompted to create the resources.

Congratulations! You've successfully used Claude to generate Terraform code, set up an EC2 workstation, installed Terraform, and created an S3 bucket. This completes Day 1 of the MultiCloud DevOps & AI Challenge.
![Screenshot 2025-03-06 194035](https://github.com/user-attachments/assets/4f4ff2ce-eaf4-47e5-a7dd-50d123f7071a)
![Screenshot 2025-03-06 194056](https://github.com/user-attachments/assets/01e8fc38-60f0-422a-8d9e-a2fde1eaa74b)


MultiCloud, DevOps & AI Challenge - Day 2 - Deploying Docker Images for an E-commerce Website with Kubernetes


Part 1 - Docker
Step 1: Install Docker on EC2
Execute the following commands:
```
sudo yum update -y
sudo yum install docker -y
sudo systemctl start docker
sudo docker run hello-world
sudo systemctl enable docker
docker --version
sudo usermod -a -G docker $(whoami)
newgrp docker
```
```
sudo usermod -a -G docker $(whoami)
newgrp docker
```
​
Step 2: Create Docker image for CloudMart
Backend
Create folder and download source code:
```
mkdir -p challenge-day2/backend && cd challenge-day2/backend
wget https://tcb-public-events.s3.amazonaws.com/mdac/resources/day2/cloudmart-backend.zip
unzip cloudmart-backend.zip
```
​
Create .env file:
```
nano .env
```
​
Content of .env:
```
PORT=5000
AWS_REGION=us-east-1
BEDROCK_AGENT_ID=<your-bedrock-agent-id>
BEDROCK_AGENT_ALIAS_ID=<your-bedrock-agent-alias-id>
OPENAI_API_KEY=<your-openai-api-key>
OPENAI_ASSISTANT_ID=<your-openai-assistant-id>
```
​
Create Dockerfile:

```nano Dockerfile```
Content of Dockerfile:

```
FROM node:18
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 5000
CMD ["npm", "start"]
```
​
Frontend
Create folder and download source code:

```
cd ..
mkdir frontend && cd frontend
wget https://tcb-public-events.s3.amazonaws.com/mdac/resources/day2/cloudmart-frontend.zip
unzip cloudmart-frontend.zip
```
Create Dockerfile:

```nano Dockerfile```

​
Content of Dockerfile:
```
FROM node:16-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build
```
```
FROM node:16-alpine
WORKDIR /app
RUN npm install -g serve
COPY --from=build /app/dist /app
ENV PORT=5001
ENV NODE_ENV=production
EXPOSE 5001
CMD ["serve", "-s", ".", "-l", "5001"]
```

​
Part 2 - Kubernetes
```
Attention: AWS Kubernetes service is not free, so when executing the hands-on below, you will be charged a few cents on your AWS account according to EKS pricing on AWS.
Remember to delete the cluster to avoid unwanted charges. Use the removal section at the end of the doc.
```

Cluster Setup on AWS Elastic Kubernetes Services (EKS)
Create a user named eksuser with Admin privileges and authenticate with it
aws configure
​
Install the CLI tool eksctl
```
curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
sudo cp /tmp/eksctl /usr/bin
eksctl version
```
​
Install the CLI tool kubectl
```
curl -o kubectl https://amazon-eks.s3.us-west-2.amazonaws.com/1.18.9/2020-11-02/bin/linux/amd64/kubectl
chmod +x ./kubectl
mkdir -p $HOME/bin && cp ./kubectl $HOME/bin/kubectl && export PATH=$PATH:$HOME/bin
echo 'export PATH=$PATH:$HOME/bin' >> ~/.bashrc
kubectl version --short --client
```
​
Create an EKS Cluster
```
eksctl create cluster \
  --name cloudmart \
  --region us-east-1 \
  --nodegroup-name standard-workers \
  --node-type t3.medium \
  --nodes 1 \
  --with-oidc \
  --managed
```
​
Connect to the EKS cluster using the kubectl configuration
```
aws eks update-kubeconfig --name cloudmart
```
​
Verify Cluster Connectivity
```
kubectl get svc
kubectl get nodes
```
​
Create a Role & Service Account to provide pods access to services used by the application (DynamoDB, Bedrock, etc).
```
eksctl create iamserviceaccount \
  --cluster=cloudmart \
  --name=cloudmart-pod-execution-role \
  --role-name CloudMartPodExecutionRole \
  --attach-policy-arn=arn:aws:iam::aws:policy/AdministratorAccess\
  --region us-east-1 \
  --approve
​```

```NOTE: In the example above, Admin privileges were used to facilitate educational purposes. Always remember to follow the principle of least privilege in production environments
```
Backend Deployment on Kubernetes
Create an ECR Repository for the Backend and upload the Docker image to it
```
Repository name: cloudmart-backend
```

​
Switch to backend folder
```
cd ../..
cd challenge-day2/backend
```
Follow the ECR steps to build your Docker image

Create a Kubernetes deployment file (YAML) for the Backend

```
cd ../..
cd challenge-day2/backend
nano cloudmart-backend.yaml
​```

apiVersion: apps/v1
kind: Deployment
metadata:
  name: cloudmart-backend-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cloudmart-backend-app
  template:
    metadata:
      labels:
        app: cloudmart-backend-app
    spec:
      serviceAccountName: cloudmart-pod-execution-role
      containers:
      - name: cloudmart-backend-app
        image: public.ecr.aws/l4c0j8h9/cloudmart-backend:latest
        env:
        - name: PORT
          value: "5000"
        - name: AWS_REGION
          value: "us-east-1"
        - name: BEDROCK_AGENT_ID
          value: "xxxxxx"
        - name: BEDROCK_AGENT_ALIAS_ID
          value: "xxxx"
        - name: OPENAI_API_KEY
          value: "xxxxxx"
        - name: OPENAI_ASSISTANT_ID
          value: "xxxx"
---

apiVersion: v1
kind: Service
metadata:
  name: cloudmart-backend-app-service
spec:
  type: LoadBalancer
  selector:
    app: cloudmart-backend-app
  ports:
    - protocol: TCP
      port: 5000
      targetPort: 5000
      
      
```


Deploy the Backend on Kubernetes
```
kubectl apply -f cloudmart-backend.yaml
```

Monitor the status of objects being created and obtain the public IP generated for the API
```
kubectl get pods
kubectl get deployment
kubectl get service
​```

Frontend Deployment on Kubernetes
Preparation
Change the Frontend's .env file to point to the API URL created within Kubernetes obtained by the kubectl get service command

```cd ../challenge-day2/frontend
nano .env


​
```
Content of .env:

```
VITE_API_BASE_URL=http://<your_url_kubernetes_api>:5000/api
```
​
Create an ECR Repository for the Frontend and upload the Docker image to it
```
Repository name: cloudmart-frontend​```


Follow the ECR steps to build your Docker image

Create a Kubernetes deployment file (YAML) for the Frontend
```nano cloudmart-frontend.yaml```

​```apiVersion: apps/v1
kind: Deployment
metadata:
  name: cloudmart-frontend-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cloudmart-frontend-app
  template:
    metadata:
      labels:
        app: cloudmart-frontend-app
    spec:
      serviceAccountName: cloudmart-pod-execution-role
      containers:
      - name: cloudmart-frontend-app
        image: public.ecr.aws/l4c0j8h9/cloudmart-frontend:latest
---

apiVersion: v1
kind: Service
metadata:
  name: cloudmart-frontend-app-service
spec:
  type: LoadBalancer
  selector:
    app: cloudmart-frontend-app
  ports:
    - protocol: TCP
      port: 5001
      targetPort: 5001
​```
Deploy the Frontend on Kubernetes
kubectl apply -f cloudmart-frontend.yaml
``
​
Monitor the status of objects being created and obtain the public IP generated for the API
````
kubectl get pods
kubectl get deployment
kubectl get service
​```

Removal
At the end of the hands-on, delete all resources:
If you delete the cluster at the end of the exercise, you'll have to recreate it for the next days. So decide what makes more sense for you: delete the cluster and recreate it every day or keep it and pay for the time it's running. However, don't forget to delete it permanently at the end of the Challenge.
```
kubectl delete service cloudmart-frontend-app-service
kubectl delete deployment cloudmart-frontend-app
kubectl delete service cloudmart-backend-app-service
kubectl delete deployment cloudmart-backend-app

eksctl delete cluster --name cloudmart --region us-east-1
```

![Screenshot 2025-03-05 150518](https://github.com/user-attachments/assets/8c410cc8-ec1b-4638-a082-a4fc9d85acd3)


# Day 3: Building a Robust CI/CD Pipeline in the MultiCloud DevOps & AI Challenge

## Part 1: CI/CD Pipeline Configuration

### Create a free account on GitHub and then create a new repository on GitHub called cloudmart

```docker
cd challenge-day2/frontend
<Run GitHub steps>
```

### Start by pushing the changes in the CloudMart application source code to GitHub

```
git status
git add -A
git commit -m "app sent to repo"
git push
```

### **Configure AWS CodePipeline**

1. **Create a New Pipeline:**
    - Access AWS CodePipeline.
    - Start the 'Create pipeline' process.
    - Name: `cloudmart-cicd-pipeline`
    - Use the GitHub repository `cloudmart-application` as the source.
    - Add the 'cloudmartBuild' project as the build stage.
    - Add the 'cloudmartDeploy' project as the deployment stage.

### Configure **AWS CodeBuild to Build the Docker Image**

1. **Create a Build Project:**
    - Give the project a name (for example, **`cloudmartBuild`**).
    - Connect it to your existing GitHub repository (**`cloudmart-application`**).
    - **Image: amazonlinux2-x86_64-standard:4.0**
    - Configure the environment to support Docker builds. Enable "Enable this flag if you want to build Docker images or want your builds to get elevated privileges"
    - Add the environment variable **ECR_REPO** with the ECR repository URI.
    - For the build specification, use the following **`buildspec.yml`**:

```yaml
version: 0.2
phases:
  install:
    runtime-versions:
      docker: 20
  pre_build:
    commands:
      - echo Logging in to Amazon ECR...
      - aws --version
      - REPOSITORY_URI=$ECR_REPO
      **- aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws/l4c0j8h9**
  build:
    commands:
      - echo Build started on `date`
      - echo Building the Docker image...
      - docker build -t $REPOSITORY_URI:latest .
      - docker tag $REPOSITORY_URI:latest $REPOSITORY_URI:$CODEBUILD_RESOLVED_SOURCE_VERSION
  post_build:
    commands:
      - echo Build completed on `date`
      - echo Pushing the Docker image...
      - docker push $REPOSITORY_URI:latest
      - docker push $REPOSITORY_URI:$CODEBUILD_RESOLVED_SOURCE_VERSION
      - export imageTag=$CODEBUILD_RESOLVED_SOURCE_VERSION
      - printf '[{\"name\":\"cloudmart-app\",\"imageUri\":\"%s\"}]' $REPOSITORY_URI:$imageTag > imagedefinitions.json
      - cat imagedefinitions.json
      - ls -l

env:
  exported-variables: ["imageTag"]

artifacts:
  files:
    - imagedefinitions.json
    - cloudmart-frontend.yaml

```

1. **Add the AmazonElasticContainerRegistryPublicFullAccess permission to ECR in the service role**
- Access the IAM console > Roles.
- Look for the role created "cloudmartBuild" for CodeBuild.
- Add the permission **AmazonElasticContainerRegistryPublicFullAccess**.

### Configure AWS CodeBuild for Application Deployment

**Create a Deployment Project:**

- Repeat the process of creating projects in CodeBuild.
- Give this project a different name (for example, **`cloudmartDeployToProduction`**).
- Configure the environment variables AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY for the credentials of the user **`eks-user`** in Cloud Build, so it can authenticate to the Kubernetes cluster.

*Note: in a real-world production environment, it is recommended to use an IAM role for this purpose. In this practical exercise, we are directly using the credentials of the* **`eks-user`** *to facilitate the process, since our focus is on CI/CD and not on user authentication at this moment. The configuration of this process in EKS is more extensive. Refer to the Reference section and check "Enabling IAM principal access to your cluster"*

- For the deployment specification, use the following **`buildspec.yml`**:

```yaml
version: 0.2

phases:
  install:
    runtime-versions:
      docker: 20
    commands:
      - curl -o kubectl https://amazon-eks.s3.us-west-2.amazonaws.com/1.18.9/2020-11-02/bin/linux/amd64/kubectl
      - chmod +x ./kubectl
      - mv ./kubectl /usr/local/bin
      - kubectl version --short --client
  post_build:
    commands:
      - aws eks update-kubeconfig --region us-east-1 --name cloudmart
      - kubectl get nodes
      - ls
      - IMAGE_URI=$(jq -r '.[0].imageUri' imagedefinitions.json)
      - echo $IMAGE_URI
      - sed -i "s|CONTAINER_IMAGE|$IMAGE_URI|g" cloudmart-frontend.yaml
      - kubectl apply -f cloudmart-frontend.yaml

```

- Replace the image URI on line 18 of the **`cloudmart-frontend.yaml`** files with CONTAINER_IMAGE.
- Commit and push the changes.

```bash
git add -A
git commit -m "replaced image uri with CONTAINER_IMAGE"
git push
```

## **Part 2: Test your CI/CD Pipeline**

1. **Make a Change on GitHub:**
    - Update the application code in the **`cloudmart-application`** repository.
    - File `src/components/MainPage/index.jsx` line 93
    - Commit and push the changes.
    
    ```bash
    git add -A
    git commit -m "changed to Featured Products on CloudMart"
    git push
    ```
    
2. **Observe the Pipeline Execution:**
    - Watch how CodePipeline automatically triggers the build.
    - After the build, the deployment phase should begin.
3. **Verify the Deployment:**
    - Check Kubernetes using **`kubectl`** commands to confirm the application update.

# MultiCloud, DevOps & AI Challenge - Day 4 (Experienced)

# Creating resources using Terraform

Navigate to the folder containing the `main.tf` file and download the zip file containing the Lambda function that will be used by Bedrock

```yaml
cd challenge-day2/backend/src/lambda
cp list_products.zip ../../../../terraform-project/
cd ../../../../terraform-project
```

Add the following lines at the end of the [main.tf](http://main.tf) file

```yaml
# IAM Role for Lambda function
resource "aws_iam_role" "lambda_role" {
  name = "cloudmart_lambda_role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

# IAM Policy for Lambda function
resource "aws_iam_role_policy" "lambda_policy" {
  name = "cloudmart_lambda_policy"
  role = aws_iam_role.lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "dynamodb:Scan",
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = [
          aws_dynamodb_table.cloudmart_products.arn,
          aws_dynamodb_table.cloudmart_orders.arn,
          aws_dynamodb_table.cloudmart_tickets.arn,
          "arn:aws:logs:*:*:*"
        ]
      }
    ]
  })
}

# Lambda function for listing products
resource "aws_lambda_function" "list_products" {
  filename         = "list_products.zip"
  function_name    = "cloudmart-list-products"
  role             = aws_iam_role.lambda_role.arn
  handler          = "index.handler"
  runtime          = "nodejs20.x"
  source_code_hash = filebase64sha256("list_products.zip")

  environment {
    variables = {
      PRODUCTS_TABLE = aws_dynamodb_table.cloudmart_products.name
    }
  }
}

# Lambda permission for Bedrock
resource "aws_lambda_permission" "allow_bedrock" {
  statement_id  = "AllowBedrockInvoke"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.list_products.function_name
  principal     = "bedrock.amazonaws.com"
}

# Output the ARN of the Lambda function
output "list_products_function_arn" {
  value = aws_lambda_function.list_products.arn
}
```

# Configuring the Amazon Bedrock Agent

Follow these steps to manually create the Bedrock Agent for CloudMart:

## Model Access:


https://file.notion.so/f/f/0d1b678b-cd91-4256-93c7-73b2e82396d5/e7b46d1e-7560-42ff-ad54-d052df77a966/Screenshare_-_2024-09-19_4_29_23_PM.mp4?table=block&id=fffe8a56-670c-8141-8ba9-d4e0a0acb46d&spaceId=0d1b678b-cd91-4256-93c7-73b2e82396d5&expirationTimestamp=1741334400000&signature=rDJj8DmGZJOs5saN7Zv0-_1sJGKemu2nGN7nAGw4xiM

1. In the Amazon Bedrock console, go to "Model access" in the navigation panel.
2. Choose "Enable specific models".
3. Select the Claude 3 Sonnet model.
4. Wait until the model access status changes to "Access granted".

## Create the Agent:

1. In the Amazon Bedrock console, choose "Agents" under "Builder tools" in the navigation panel.
2. Click on "Create agent".
3. Name the agent "cloudmart-product-recommendation-agent".
4. Select "Claude 3 Sonnet" as the base model.
5. Paste the agent instructions below in the "Instructions for the Agent" section.
    
    ```yaml
    You are a product recommendations agent for CloudMart, an online e-commerce store. Your role is to assist customers in finding products that best suit their needs. Follow these instructions carefully:
    
    1. Begin each interaction by retrieving the full list of products from the API. This will inform you of the available products and their details.
    
    2. Your goal is to help users find suitable products based on their requirements. Ask questions to understand their needs and preferences if they're not clear from the user's initial input.
    
    3. Use the 'name' parameter to filter products when appropriate. Do not use or mention any other filter parameters that are not part of the API.
    
    4. Always base your product suggestions solely on the information returned by the API. Never recommend or mention products that are not in the API response.
    
    5. When suggesting products, provide the name, description, and price as returned by the API. Do not invent or modify any product details.
    
    6. If the user's request doesn't match any available products, politely inform them that we don't currently have such products and offer alternatives from the available list.
    
    7. Be conversational and friendly, but focus on helping the user find suitable products efficiently.
    
    8. Do not mention the API, database, or any technical aspects of how you retrieve the information. Present yourself as a knowledgeable sales assistant.
    
    9. If you're unsure about a product's availability or details, always check with the API rather than making assumptions.
    
    10. If the user asks about product features or comparisons, use only the information provided in the product descriptions from the API.
    
    11. Be prepared to assist with a wide range of product inquiries, as our e-commerce store may carry various types of items.
    
    12. If a user is looking for a specific type of product, use the 'name' parameter to search for relevant items, but be aware that this may not capture all categories or types of products.
    
    Remember, your primary goal is to help users find the best products for their needs from what's available in our store. Be helpful, informative, and always base your recommendations on the actual product data provided by the API.
    ```
    

## Configure the IAM Role:

1. In the Bedrock Agent overview, locate the 'Permissions' section.
2. Click on the IAM role link. This will take you to the IAM console with the correct role selected.
3. In the IAM console, choose "Add permissions" and then "Create inline policy".
4. In the JSON tab, paste the following policy:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "lambda:InvokeFunction",
      "Resource": "arn:aws:lambda:*:*:function:cloudmart-list-products"
    },
    {
      "Effect": "Allow",
      "Action": "bedrock:InvokeModel",
      "Resource": "arn:aws:bedrock:*::foundation-model/anthropic.claude-3-sonnet-20240229-v1:0"
    }
  ]
}

```

1. Replace cloudmart-list-products with the actual name of your Lambda function, if different.
2. Name the policy (for example, "BedrockAgentLambdaAccess") and create it.
3. Verify that the new policy is attached to the role.

## Configure the Action Group:

1. In the "Action groups" section, create a new group called "Get-Product-Recommendations".
2. Set the action group type as "Define with API schemas".
3. Select the Lambda function "cloudmart-list-products" as the action group executor.
4. In the "Action group schema" section, choose "Define via in-line schema editor".
5. Paste the OpenAPI schema below into the schema editor.

```json
{
    "openapi": "3.0.0",
    "info": {
        "title": "Product Details API",
        "version": "1.0.0",
        "description": "This API retrieves product information. Filtering parameters are passed as query strings. If query strings are empty, it performs a full scan and retrieves the full product list."
    },
    "paths": {
        "/products": {
            "get": {
                "summary": "Retrieve product details",
                "description": "Retrieves a list of products based on the provided query string parameters. If no parameters are provided, it returns the full list of products.",
                "parameters": [
                    {
                        "name": "name",
                        "in": "query",
                        "description": "Retrieve details for a specific product by name",
                        "schema": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful response",
                        "content": {
                            "application/json": {
                                "schema": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "name": {
                                                "type": "string"
                                            },
                                            "description": {
                                                "type": "string"
                                            },
                                            "price": {
                                                "type": "number"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "content": {
                            "application/json": {
                                "schema": {
                                    "$ref": "#/components/schemas/ErrorResponse"
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    "components": {
        "schemas": {
            "ErrorResponse": {
                "type": "object",
                "properties": {
                    "error": {
                        "type": "string",
                        "description": "Error message"
                    }
                },
                "required": [
                    "error"
                ]
            }
        }
    }
}
```

## Review and Create:

1. Review all agent configurations.
2. Click on "Prepare agent" to finalize the creation.

## Test the Agent:

1. After creation, use the "Test Agent" panel to have conversations with the chatbot.
2. Verify if the agent is asking relevant questions about the recipient's gender, occasion, and desired category.
3. Confirm if the agent is consulting the API and presenting appropriate product recommendations.

## Create an Alias for the Agent:

1. On the agent details page, go to the "Aliases" section.
2. Click on "Create alias".
3. Name the alias "cloudmart-prod".
4. Select the most recent version of the agent.
5. Click on "Create alias" to finalize.

Note: Make sure that the Lambda function name in the IAM policy matches the actual name of your function and adjust the region in the ARNs if you're not using us-east-1.

# OpenAI Assistant Configuration

Follow these steps to create an OpenAI assistant for CloudMart:

## OpenAI Access:

1. Access the OpenAI platform (https://platform.openai.com/).
2. Log in or create an account if you don't have one yet.

![image](https://github.com/user-attachments/assets/df5ac82a-437e-4484-82bf-6eb99d135c79)

Note: You will need to add at least $5.00 credit for the API to work. Follow the steps below:


## Create the Assistant:

1. Navigate to the "Assistants" section.
2. Click on "Create New Assistant".
3. Name the assistant "CloudMart Customer Support".
4. Select the model `gpt-4o`.

## Configure the Assistant:

1. In the "Instructions" section, paste the following:
    
    ```yaml
    You are a customer support agent for CloudMart, an e-commerce platform. Your role is to assist customers with general inquiries, order issues, and provide helpful information about using the CloudMart platform. You don't have direct access to specific product or inventory information. Always be polite, patient, and focus on providing excellent customer service. If a customer asks about specific products or inventory, politely explain that you don't have access to that information and suggest they check the website or speak with a sales representative.
    ```
    
2. In "Capabilities", you can enable "Code Interpreter" if you want the assistant to help with technical aspects of using the platform.

## Save the Assistant:

1. After creating the assistant it is going to auto-save.
2. Note down the Assistant ID, you'll need it for your environment variables.

## Generate API Key:

1. Go to the API Keys section in your OpenAI account.
2. Generate a new API key.
3. Copy this key, you'll need it for your environment variables.

# Redeploy the backend with AI Assistants

## Update the `cloudmart-backend.yaml` file with AI Assistants information

Open the `cloudmart-backend.yaml` file:

```bash
nano cloudmart-backend.yaml
```

Content of `cloudmart-backend.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cloudmart-backend-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cloudmart-backend-app
  template:
    metadata:
      labels:
        app: cloudmart-backend-app
    spec:
      serviceAccountName: cloudmart-pod-execution-role
      containers:
      - name: cloudmart-backend-app
        image: public.ecr.aws/l4c0j8h9/cloudmaster-backend:latest
        env:
        - name: PORT
          value: "5000"
        - name: AWS_REGION
          value: "us-east-1"
        - name: BEDROCK_AGENT_ID
          value: "xxxx"
        - name: BEDROCK_AGENT_ALIAS_ID
          value: "xxxx"
        - name: OPENAI_API_KEY
          value: "xxxx"
        - name: OPENAI_ASSISTANT_ID
          value: "xxxx"
---

apiVersion: v1
kind: Service
metadata:
  name: cloudmart-backend-app-service
spec:
  type: LoadBalancer
  selector:
    app: cloudmart-backend-app
  ports:
    - protocol: TCP
      port: 5000
      targetPort: 5000
```

## Update the deployment in Kubernetes

```json
kubectl apply -f cloudmart-backend.yaml
```

# Test the AI Assistant
